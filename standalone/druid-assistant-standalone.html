<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Druid's Wildshape and Conjure Animals Assistant</title>
    <!-- Bootstrap CDN -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <!-- Embedded CSS -->
    <style>
    /* CSS content will be embedded here */
    </style>
</head>
<body>
    <!-- HTML content will be embedded here -->
    
    <!-- Bootstrap JS -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    
    <!-- Embedded JavaScript and Markdown data -->
    <script>
    // Beast data in markdown format
    const beastDataMarkdown = `___
>## Allosaurus
>*Large Beast, unaligned*
>___
>- **Armor Class** 13 (natural armor)
>- **Hit Points** 51 (6d10 + 18)
>- **Speed** 60 ft.
>___
>|STR|DEX|CON|INT|WIS|CHA|
>|:---:|:---:|:---:|:---:|:---:|:---:|
>|19 (+4)|13 (+1)|17 (+3)|2 (-4)|12 (+1)|5 (-3)|
>___
>- **Skills** Perception +5
>- **Senses** passive Perception 15
>- **Languages** â€”
>- **Challenge** 2 (450 XP)
>- **Proficiency Bonus** +2
>___
>***Pounce.*** If the allosaurus moves at least 30 feet straight toward a creature and then hits it with a claw attack on the same turn, that target must succeed on a DC 13 Strength saving throw or be knocked prone. If the target is prone, the allosaurus can make one bite attack against it as a bonus action.  
>
>### Actions
>***Bite.*** *Melee Weapon Attack:*  +6 to hit, reach 5 ft., one target. *Hit:* 15 (2d10 + 4) piercing damage.  
>
>***Claw.*** *Melee Weapon Attack:*  +6 to hit, reach 5 ft., one target. *Hit:* 8 (1d8 + 4) slashing damage.  
>

// ---- This is just a sample of the first beast. Due to size limitations, the full markdown data will be embedded in the next step ----
`;

    // data.js - Modified version for standalone HTML file
    const DataManager = (function() {
        // Database configuration
        const DB_NAME = 'DruidsAssistantDB';
        const DB_VERSION = 2;
        const BEAST_STORE = 'beasts';
        const FAVORITES_STORE = 'favorites';
        const WILDSHAPE_FAVORITES_STORE = 'wildshapeFavorites';
        const CONJURE_FAVORITES_STORE = 'conjureFavorites';
        
        // IndexedDB instance
        let db = null;
        
        /**
         * Initializes the IndexedDB database
         * @returns {Promise} Resolves when the database is ready
         */
        function initDatabase() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, DB_VERSION);
                
                request.onerror = (event) => {
                    console.error('Database error:', event.target.error);
                    reject('Could not open database');
                };
                
                request.onsuccess = (event) => {
                    db = event.target.result;
                    console.log('Database opened successfully');
                    resolve(db);
                };
                
                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    const oldVersion = event.oldVersion;
                    
                    // Create object stores if they don't exist
                    if (!db.objectStoreNames.contains(BEAST_STORE)) {
                        const beastStore = db.createObjectStore(BEAST_STORE, { keyPath: 'id' });
                        beastStore.createIndex('name', 'name', { unique: false });
                        beastStore.createIndex('cr', 'cr', { unique: false });
                        beastStore.createIndex('type', 'type', { unique: false });
                    }
                    
                    if (!db.objectStoreNames.contains(FAVORITES_STORE)) {
                        db.createObjectStore(FAVORITES_STORE, { keyPath: 'id' });
                    }
                    
                    // New stores for separate favorites (added in version 2)
                    if (oldVersion < 2) {
                        if (!db.objectStoreNames.contains(WILDSHAPE_FAVORITES_STORE)) {
                            db.createObjectStore(WILDSHAPE_FAVORITES_STORE, { keyPath: 'id' });
                        }
                        
                        if (!db.objectStoreNames.contains(CONJURE_FAVORITES_STORE)) {
                            db.createObjectStore(CONJURE_FAVORITES_STORE, { keyPath: 'id' });
                        }
                        
                        // Migrate existing favorites if upgrading from v1 to v2
                        if (oldVersion === 1 && db.objectStoreNames.contains(FAVORITES_STORE)) {
                            // We'll handle the migration after the upgrade completes
                            console.log('Will migrate favorites to separate stores');
                        }
                    }
                    
                    console.log('Database setup complete');
                };
            });
        }
        
        /**
         * Parses a markdown string containing beast data
         * @param {string} markdown - Markdown text to parse
         * @returns {Array} Array of beast objects
         */
        function parseMarkdown(markdown) {
            const beasts = [];
            let currentBeast = null;
            let inStatBlock = false;
            let currentSection = null;
            
            // Split markdown into lines
            const lines = markdown.split('\n');
            
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                
                // Check for beast header (starts with '>## ')
                if (line.startsWith('>## ')) {
                    // If we were processing a beast, save it
                    if (currentBeast) {
                        beasts.push(currentBeast);
                    }
                    
                    // Start a new beast
                    const name = line.substring(4).trim();
                    // Ensure name is valid and create a consistent ID
                    const id = name.toLowerCase()
                        .replace(/[^a-z0-9]/g, '-')
                        .replace(/-+/g, '-')  // Replace multiple hyphens with single hyphen
                        .replace(/^-|-$/g, ''); // Remove leading/trailing hyphens
                    
                    console.log(`Parsing beast: ${name}, ID: ${id}`);
                    
                    currentBeast = {
                        id: id,
                        name: name,
                        traits: [],
                        actions: [],
                        reactions: [],
                        legendaryActions: []
                    };
                    inStatBlock = true;
                    currentSection = null;
                    continue;
                }
                
                // If not processing a beast, skip
                if (!currentBeast) continue;
                
                // Check for end of statblock
                if (line === 'null' && inStatBlock) {
                    inStatBlock = false;
                    continue;
                }
                
                // Inside statblock processing
                if (inStatBlock) {
                    // Handle basic properties
                    if (line.startsWith('>- **Armor Class**')) {
                        currentBeast.ac = line.substring(18).trim();
                    }
                    else if (line.startsWith('>- **Hit Points**')) {
                        currentBeast.hp = line.substring(17).trim();
                    }
                    else if (line.startsWith('>- **Speed**')) {
                        currentBeast.speed = line.substring(12).trim();
                    }
                    // Handle ability scores table
                    else if (line.startsWith('>|STR|DEX|CON|INT|WIS|CHA|')) {
                        try {
                            // The ability scores table typically consists of three lines:
                            // >|STR|DEX|CON|INT|WIS|CHA|
                            // >|:---:|:---:|:---:|:---:|:---:|:---:|
                            // >|19 (+4)|13 (+1)|17 (+3)|2 (-4)|12 (+1)|5 (-3)|
                            
                            // Skip the separator line (line with :---:)
                            i += 1;
                            
                            // Get the values line (should be two lines after the header)
                            if (i + 1 < lines.length) {
                                const valuesLine = lines[i + 1].trim();
                                
                                // Validate this is the values line
                                if (valuesLine.startsWith('>|') && valuesLine.endsWith('|')) {
                                    // Extract the values, remove leading >| and trailing |
                                    const values = valuesLine.substring(2, valuesLine.length - 1).split('|');
                                    
                                    // Verify we have exactly 6 values
                                    if (values.length === 6) {
                                        // Create the abilities object with correct mapping
                                        currentBeast.abilities = {
                                            str: values[0].trim(),
                                            dex: values[1].trim(),
                                            con: values[2].trim(),
                                            int: values[3].trim(),
                                            wis: values[4].trim(),
                                            cha: values[5].trim()
                                        };
                                        
                                        console.log(`Parsed abilities for ${currentBeast.name}:`, currentBeast.abilities);
                                        
                                        // Skip the values line since we've processed it
                                        i += 1;
                                    } else {
                                        throw new Error(`Expected 6 ability values, found ${values.length} in line: ${valuesLine}`);
                                    }
                                } else {
                                    throw new Error(`Expected ability score values line, found: ${valuesLine}`);
                                }
                            } else {
                                throw new Error('Unexpected end of file when parsing ability scores');
                            }
                        } catch (error) {
                            console.error(`Error parsing ability scores for ${currentBeast.name}:`, error);
                            // Use default abilities as fallback
                            currentBeast.abilities = {
                                str: "10 (+0)",
                                dex: "10 (+0)",
                                con: "10 (+0)",
                                int: "10 (+0)",
                                wis: "10 (+0)",
                                cha: "10 (+0)"
                            };
                        }
                    }
                    // Handle skills, senses, etc.
                    else if (line.startsWith('>- **Skills**')) {
                        currentBeast.skills = line.substring(14).trim();
                    }
                    else if (line.startsWith('>- **Senses**')) {
                        currentBeast.senses = line.substring(14).trim();
                    }
                    else if (line.startsWith('>- **Languages**')) {
                        currentBeast.languages = line.substring(17).trim();
                    }
                    else if (line.startsWith('>- **Challenge**')) {
                        const crParts = line.substring(16).trim().split(' ');
                        currentBeast.cr = crParts[0];
                        currentBeast.xp = crParts[1]?.replace(/[\(\)]/g, '');
                    }
                    else if (line.startsWith('>- **Damage Resistances**')) {
                        currentBeast.damageResistances = line.substring(26).trim();
                    }
                    else if (line.startsWith('>- **Damage Vulnerabilities**')) {
                        currentBeast.damageVulnerabilities = line.substring(30).trim();
                    }
                    else if (line.startsWith('>- **Damage Immunities**')) {
                        currentBeast.damageImmunities = line.substring(25).trim();
                    }
                    else if (line.startsWith('>- **Condition Immunities**')) {
                        currentBeast.conditionImmunities = line.substring(28).trim();
                    }
                    // Handle traits/features
                    else if (line.startsWith('>***')) {
                        const traitText = line.substring(4);
                        const endIndex = traitText.indexOf('***');
                        if (endIndex !== -1) {
                            const traitName = traitText.substring(0, endIndex).trim();
                            const traitDesc = traitText.substring(endIndex + 3).trim();
                            
                            if (currentSection === 'actions') {
                                currentBeast.actions.push({
                                    name: traitName,
                                    desc: traitDesc
                                });
                            } else if (currentSection === 'reactions') {
                                currentBeast.reactions.push({
                                    name: traitName,
                                    desc: traitDesc
                                });
                            } else if (currentSection === 'legendaryActions') {
                                currentBeast.legendaryActions.push({
                                    name: traitName,
                                    desc: traitDesc
                                });
                            } else {
                                currentBeast.traits.push({
                                    name: traitName,
                                    desc: traitDesc
                                });
                            }
                        }
                    }
                    // Handle section headers
                    else if (line.startsWith('>### Actions')) {
                        currentSection = 'actions';
                    }
                    else if (line.startsWith('>### Reactions')) {
                        currentSection = 'reactions';
                    }
                    else if (line.startsWith('>### Legendary Actions')) {
                        currentSection = 'legendaryActions';
                    }
                    // Handle type and size from subtitle line
                    else if (line.startsWith('>*') && !currentBeast.size) {
                        const subtitleMatch = line.match(/>*([A-Za-z]+) ([A-Za-z]+)(?: \(([A-Za-z]+)\))?, ([a-z ]+)\*/i);
                        if (subtitleMatch) {
                            currentBeast.size = subtitleMatch[1];
                            currentBeast.type = subtitleMatch[2];
                            currentBeast.subtype = subtitleMatch[3] || '';
                            currentBeast.alignment = subtitleMatch[4];
                            currentBeast.environment = 'forest, grassland, hills'; // Adding default environment from the file name
                        }
                    }
                }
                // Outside statblock - look for beast description
                else if (line.startsWith('## ') && line.substring(3).trim() === currentBeast.name) {
                    // The next lines contain the description
                    let descriptionLines = [];
                    let j = i + 1;
                    
                    while (j < lines.length && !lines[j].startsWith('___') && !lines[j].startsWith('## ')) {
                        if (lines[j].trim().length > 0) {
                            descriptionLines.push(lines[j].trim());
                        }
                        j++;
                    }
                    
                    if (descriptionLines.length > 0) {
                        currentBeast.description = descriptionLines.join('\n');
                    }
                    
                    // Skip to the end of the description
                    i = j - 1;
                }
            }
            
            // Add the last beast if there is one
            if (currentBeast) {
                beasts.push(currentBeast);
            }
            
            // Process each beast to extract attack information and fix any formatting issues
            beasts.forEach(beast => {
                // Add default abilities if missing
                if (!beast.abilities) {
                    console.warn(`Beast ${beast.name} is missing ability scores, using defaults`);
                    beast.abilities = {
                        str: "10 (+0)",
                        dex: "10 (+0)",
                        con: "10 (+0)",
                        int: "10 (+0)",
                        wis: "10 (+0)",
                        cha: "10 (+0)"
                    };
                }
                
                // Process traits and actions to find attack information
                processAttackInfo(beast);
            });
            
            console.log(`Successfully parsed ${beasts.length} beasts`);
            return beasts;
        }
        
        /**
         * Processes a beast to extract attack information from actions and traits
         * @param {Object} beast - Beast object to process
         */
        function processAttackInfo(beast) {
            // Process actions
            if (beast.actions) {
                beast.actions.forEach(action => {
                    if (action.desc.includes('Weapon Attack:') || action.desc.includes('Melee Attack:') || action.desc.includes('Ranged Attack:')) {
                        const attackMatch = action.desc.match(/([A-Za-z]+ (?:Weapon|Melee|Ranged) Attack:)\s*\+(\d+) to hit/);
                        if (attackMatch) {
                            action.attackType = attackMatch[1];
                            action.attackBonus = attackMatch[2];
                        }
                        
                        const damageMatch = action.desc.match(/Hit: (\d+) \(([^\)]+)\) ([a-z]+) damage/);
                        if (damageMatch) {
                            action.damageAvg = damageMatch[1];
                            action.damageDice = damageMatch[2];
                            action.damageType = damageMatch[3];
                        }
                    }
                });
            }
            
            // Process traits for attack information (some beasts have attacks in traits)
            if (beast.traits && (!beast.actions || beast.actions.length === 0)) {
                beast.traits.forEach(trait => {
                    if (trait.desc.includes('Weapon Attack:') || trait.desc.includes('Melee Attack:') || trait.desc.includes('Ranged Attack:')) {
                        // If this trait is an attack, create an action from it
                        const attackMatch = trait.desc.match(/([A-Za-z]+ (?:Weapon|Melee|Ranged) Attack:)\s*\+(\d+) to hit/);
                        const damageMatch = trait.desc.match(/Hit: (\d+) \(([^\)]+)\) ([a-z]+) damage/);
                        
                        if (attackMatch) {
                            // Create a new action based on this trait
                            const action = {
                                name: trait.name,
                                desc: trait.desc,
                                attackType: attackMatch[1],
                                attackBonus: attackMatch[2]
                            };
                            
                            if (damageMatch) {
                                action.damageAvg = damageMatch[1];
                                action.damageDice = damageMatch[2];
                                action.damageType = damageMatch[3];
                            }
                            
                            // Add to actions
                            if (!beast.actions) {
                                beast.actions = [];
                            }
                            beast.actions.push(action);
                        }
                    }
                });
            }
        }
        
        /**
         * Saves beasts to IndexedDB
         * @param {Array} beasts - Array of beast objects to save
         * @returns {Promise} Resolves when save is complete
         */
        function saveBeasts(beasts) {
            return new Promise((resolve, reject) => {
                if (!db) {
                    reject('Database not initialized');
                    return;
                }
                
                const transaction = db.transaction([BEAST_STORE], 'readwrite');
                const store = transaction.objectStore(BEAST_STORE);
                
                let savedCount = 0;
                
                transaction.oncomplete = () => {
                    console.log(`Saved ${savedCount} beasts`);
                    resolve(savedCount);
                };
                
                transaction.onerror = (event) => {
                    console.error('Transaction error:', event.target.error);
                    reject('Error saving beasts');
                };
                
                beasts.forEach(beast => {
                    try {
                        const request = store.put(beast);
                        request.onsuccess = () => {
                            savedCount++;
                        };
                        request.onerror = (event) => {
                            console.error(`Error saving beast ${beast.name}:`, event.target.error);
                        };
                    } catch (e) {
                        console.error(`Exception while saving beast ${beast.name}:`, e);
                    }
                });
            });
        }
        
        // Rest of the DataManager implementation... (will be continued in next edits)
        
        /**
         * Gets all beasts from IndexedDB
         */
        function getAllBeasts() {
            return new Promise((resolve, reject) => {
                if (!db) {
                    reject('Database not initialized');
                    return;
                }
                
                const transaction = db.transaction([BEAST_STORE], 'readonly');
                const store = transaction.objectStore(BEAST_STORE);
                const request = store.getAll();
                
                request.onsuccess = () => {
                    console.log(`Retrieved ${request.result.length} beasts from database`);
                    resolve(request.result);
                };
                
                request.onerror = (event) => {
                    console.error('Request error:', event.target.error);
                    reject('Error getting beasts');
                };
            });
        }

        // Modified to use embedded markdown data instead of fetching
        function loadBeastData() {
            return new Promise((resolve, reject) => {
                try {
                    console.log('Starting beast data parsing...');
                    const beasts = parseMarkdown(beastDataMarkdown);
                    
                    if (beasts.length === 0) {
                        reject('No beasts found in markdown');
                        return;
                    }
                    
                    console.log(`Parsed ${beasts.length} beasts, first beast: ${beasts[0].name}`);
                    
                    saveBeasts(beasts)
                        .then(count => {
                            console.log(`Successfully saved ${count} beasts to IndexedDB`);
                            resolve(count);
                        })
                        .catch(error => {
                            console.error('Error saving beasts:', error);
                            reject(error);
                        });
                } catch (error) {
                    console.error('Error parsing markdown:', error);
                    reject('Error parsing markdown: ' + error.message);
                }
            });
        }

        // Additional DataManager API methods will be added in subsequent edits
        
        // Public API
        return {
            initDatabase,
            parseMarkdown,
            saveBeasts,
            getAllBeasts,
            loadBeastData
            // Rest of the API will be added in subsequent edits
        };
    })();
    
    // ui.js code will be embedded here
    
    // Initialization code to load data and start the app
    document.addEventListener('DOMContentLoaded', function() {
        console.log('Initializing Druid Assistant standalone version...');
        
        // Initialize the database
        DataManager.initDatabase()
            .then(() => {
                console.log('Database initialized, checking for beast data...');
                
                // Check if we have beasts already
                return DataManager.getAllBeasts();
            })
            .then(beasts => {
                if (beasts.length === 0) {
                    console.log('No beasts found in database, loading from embedded data...');
                    return DataManager.loadBeastData();
                } else {
                    console.log(`Found ${beasts.length} beasts in database, no need to reload`);
                    return beasts.length;
                }
            })
            .then(count => {
                console.log(`Database contains ${count} beasts, initialization complete!`);
                // Initialize UI will be handled in Part 2
            })
            .catch(error => {
                console.error('Error during initialization:', error);
                alert('There was an error initializing the application. Please check the console for details.');
            });
    });
    </script>
</body>
</html>